import angr
import monkeyhex
import claripy
import archinfo

# todo: extend this to work with an arbitrary number of arguments


def main():
    '''
     load the binary, don't load extra libs to save time/memory from state explosion
    '''
    project = angr.Project('overflow', load_options={'auto_load_libs':False})
    
    '''
     Add symbolic variable for the input buffer which we are solving for:
    '''
    sym_arg_size = 4  #max number of bytes we'll try to solve for
    
    '''
    create an initial state with a symbolic bit vector as argv1
    '''
    argv0 = project.filename
    argv1 = claripy.BVS("argv1",8*sym_arg_size)
    # argv1 = "BBBBB"
    init_state = project.factory.entry_state(args=[argv0,argv1])

    '''
    create a simulationManager from the entry state
    ''' 
    sm = project.factory.simulation_manager(init_state)

    '''
    get the address of 'strcpy'
    todo: verify this is working by looking at the disassembly
    you should get 0x550
        0x00000000000006a8 <+30>:    callq  0x550 <strcpy@plt>
    '''
    # strcpy_addr = project.loader.find_symbol('strcpy')  # this did not work :(

    '''
     Set up CFG so we can grab function addresses from symbols.
     I set the fail_fast option to True to minimize how long
     this process takes.
    '''
    cfg = project.analyses.CFG(fail_fast=True)
    

    '''
     Just a helper function to grab function names from resolved symbols.
     This will not be so easy if the binary is stripped.  You will have to
     open the binary in a disassembler and find the addresses of the
     functions you are trying to find/avoid in your paths rather than using
     this helper function.

     Note: why does this still work even after stripping the binary?
    '''
    def getFuncAddress( funcName, plt=None ):
        found = [
            addr for addr,func in cfg.kb.functions.items()
            if funcName == func.name and (plt is None or func.is_plt == plt)
            ]
        if len( found ) > 0:
            print("Found "+funcName+"'s address at "+hex(found[0])+"!")
            return found[0]
        else:
            raise Exception("No address found for function : "+funcName)


    strcpy_addr = getFuncAddress('strcpy', plt=True)

    def check(state):
        
        if (state.ip.args[0] == strcpy_addr):    # Ensure that we're at strcpy
            '''
             By looking at the disassembly, I've found that the pointer to the
             source buffer given to strcpy() is kept in RSI.  Here, we dereference
             the pointer in RSI and grab 8 bytes (len("yeet!")) from that buffer.

            todo: make sure usage of rsi is consistent across architectures

            if the first 8 bytes are the same as argv1, it is likely that
            argv1 is the src param of strcpy
            '''
            BV_strCpySrc = state.memory.load( state.regs.rsi, sym_arg_size )

            '''
             Now we simply return True (found path) if we've found a path to strcpy
             where we control the source buffer, or False (keep looking for paths) if we
             don't control the source buffer
            '''
            isExploitable = BV_strCpySrc == argv1
            return state.solver.is_true(isExploitable)

        else:
            '''
             If we aren't in the strcpy function, we need to tell angr to keep looking
             for new paths.
            '''
            return False
    
    '''
    Get the first encountered state satisfying the check, if any
    '''
    sm = sm.explore(find=check)
    found = sm.found

    if len(found) == 0:    #   Make sure we found a path
        # Aww somehow we didn't find a path.  Time to work on that check() function!
        print("Couldn't find any paths which satisfied our conditions.")
    else:   
        print("Found a vulnerable strcpy: " + repr(found[0]))

    v_state = found[0]

    print(v_state.memory.load( v_state.regs.rdi, 5))
    print(v_state.memory.load( v_state.regs.rsi, sym_arg_size))

    def getBufferAddr(state):
        i = 0
        strcpy_frame = v_state.callstack.top
        while True:
            # the stack ptr is always pointing to the return address of that frame
            addr = state.memory.load( strcpy_frame.current_stack_pointer + i, 8, endness=archinfo.Endness.LE )
            data = state.memory.load( addr, sym_arg_size )
            if state.solver.is_true(data == argv1):
                return addr
            # change to increments of 1 to support non 8-bit aligned memory
            i += 8
    
    def getRetAddressAddr(state):
        i = 0
        strcpy_frame = state.callstack.top
        caller_frame = state.callstack.pop()
        ret_addr = caller_frame.ret_addr
        while True:
            addr = state.memory.load( strcpy_frame.current_stack_pointer + i, 8, endness=archinfo.Endness.LE )
            if state.solver.is_true(addr == ret_addr):
                return addr
            # change to increments of 1 to support non 8-bit aligned memory
            i += 8
    
    buff_addr = getBufferAddr(v_state)
    ret_addr  = getRetAddressAddr(v_state)

    print(v_state)

    


    # i = 1
    # print(v_state.memory.load( caller_frame.current_stack_pointer, 64, endness=archinfo.Endness.LE))
    # addr = v_state.memory.load( caller_frame.current_stack_pointer+16, 8, endness=archinfo.Endness.LE)
    # print(addr)
    # print(v_state.memory.load( addr, sym_arg_size))

    # print(argv1)

    # print(hex(caller_frame.ret_addr))


        
    
    
    
if __name__ == '__main__':
    # main()
    print(repr(main()))

# Usefull adresses:

# function: 0x40068a
# main: 0x4006e8
    
# Dump of assembler code for function main:
#    0x00000000000006b0 <+0>:     push   %rbp
#    0x00000000000006b1 <+1>:     mov    %rsp,%rbp
#    0x00000000000006b4 <+4>:     sub    $0x20,%rsp
#    0x00000000000006b8 <+8>:     mov    %edi,-0x14(%rbp)
#    0x00000000000006bb <+11>:    mov    %rsi,-0x20(%rbp)
#    0x00000000000006bf <+15>:    movl   $0x0,-0x4(%rbp)
#    0x00000000000006c6 <+22>:    mov    -0x20(%rbp),%rax
#    0x00000000000006ca <+26>:    add    $0x8,%rax
#    0x00000000000006ce <+30>:    mov    (%rax),%rax
#    0x00000000000006d1 <+33>:    mov    %rax,%rdi
#    0x00000000000006d4 <+36>:    callq  0x68a <function>
#    0x00000000000006d9 <+41>:    movl   $0x1,-0x4(%rbp)
#    0x00000000000006e0 <+48>:    mov    -0x4(%rbp),%eax
#    0x00000000000006e3 <+51>:    mov    %eax,%esi
#    0x00000000000006e5 <+53>:    lea    0x98(%rip),%rdi        # 0x784
#    0x00000000000006ec <+60>:    mov    $0x0,%eax
#    0x00000000000006f1 <+65>:    callq  0x560 <printf@plt>
#    0x00000000000006f6 <+70>:    nop
#    0x00000000000006f7 <+71>:    leaveq 
#    0x00000000000006f8 <+72>:    retq   
# End of assembler dump.

# Dump of assembler code for function function:
#    0x000000000000068a <+0>:     push   %rbp
#    0x000000000000068b <+1>:     mov    %rsp,%rbp
#    0x000000000000068e <+4>:     sub    $0x20,%rsp
#    0x0000000000000692 <+8>:     mov    %rdi,-0x18(%rbp)
#    0x0000000000000696 <+12>:    movb   $0x0,-0x1(%rbp)
#    0x000000000000069a <+16>:    mov    -0x18(%rbp),%rdx
#    0x000000000000069e <+20>:    lea    -0x5(%rbp),%rax
#    0x00000000000006a2 <+24>:    mov    %rdx,%rsi
#    0x00000000000006a5 <+27>:    mov    %rax,%rdi
#    0x00000000000006a8 <+30>:    callq  0x550 <strcpy@plt>
#    0x00000000000006ad <+35>:    nop
#    0x00000000000006ae <+36>:    leaveq 
#    0x00000000000006af <+37>:    retq   
# End of assembler dump.