import angr
import monkeyhex
import claripy
import archinfo

# todo: extend this to work with an arbitrary number of arguments


def main():
    '''
     load the binary, don't load extra libs to save time/memory from state explosion
    '''
    project = angr.Project('overflow', load_options={'auto_load_libs':False})
    
    '''
     Add symbolic variable for the input buffer which we are solving for:
    '''
    sym_arg_size = 4  #max number of bytes we'll try to solve for
    
    '''
    create an initial state with a symbolic bit vector as argv1
    '''
    argv0 = project.filename
    argv1 = claripy.BVS("argv1",8*sym_arg_size)
    # argv1 = "BBBB"
    init_state = project.factory.entry_state(args=[argv0,argv1])

    '''
    create a simulationManager from the entry state
    ''' 
    sm = project.factory.simulation_manager(init_state)

    '''
    get the address of 'strcpy'
    todo: verify this is working by looking at the disassembly
    you should get 0x550
        0x00000000000006a8 <+30>:    callq  0x550 <strcpy@plt>
    '''
    # strcpy_addr = project.loader.find_symbol('strcpy')  # this did not work :(

    '''
     Set up CFG so we can grab function addresses from symbols.
     I set the fail_fast option to True to minimize how long
     this process takes.
    '''
    cfg = project.analyses.CFG(fail_fast=True)
    

    '''
     Just a helper function to grab function names from resolved symbols.
     This will not be so easy if the binary is stripped.  You will have to
     open the binary in a disassembler and find the addresses of the
     functions you are trying to find/avoid in your paths rather than using
     this helper function.

     Note: why does this still work even after stripping the binary?
    '''
    def getFuncAddress( funcName, plt=None ):
        found = [
            addr for addr,func in cfg.kb.functions.items()
            if funcName == func.name and (plt is None or func.is_plt == plt)
            ]
        if len( found ) > 0:
            print("Found "+funcName+"'s address at "+hex(found[0])+"!")
            return found[0]
        else:
            raise Exception("No address found for function : "+funcName)


    strcpy_addr = getFuncAddress('strcpy', plt=True)

    def check(state):
        
        if (state.ip.args[0] == strcpy_addr):    # Ensure that we're at strcpy
            '''
             By looking at the disassembly, I've found that the pointer to the
             source buffer given to strcpy() is kept in RSI.  Here, we dereference
             the pointer in RSI and grab a number of bytes equal to that of argv1 
             from that buffer.

            todo: make sure usage of rsi is consistent across architectures

            '''
            BV_strCpySrc = state.memory.load( state.regs.rsi, sym_arg_size )

            '''
             Now we simply return True (found path) if we've found a path to strcpy
             where we control the source buffer, or False (keep looking for paths) if we
             don't control the source buffer
            '''
            isExploitable = BV_strCpySrc == argv1
            return state.solver.is_true(isExploitable)

        else:
            '''
             If we aren't in the strcpy function, we need to tell angr to keep looking
             for new paths.
            '''
            return False
    
    '''
    Get the first encountered state satisfying the check, if any
    '''
    sm = sm.explore(find=check)
    found = sm.found

    if len(found) == 0:    #   Make sure we found a path
        # Aww somehow we didn't find a path.  Time to work on that check() function!
        print("Couldn't find any paths which satisfied our conditions.")
    else:   
        print("Found a vulnerable strcpy: " + repr(found[0]))

    v_state = found[0]


    def getRetAddressAddr(state, increment):
        strcpy_frame = state.callstack.top
        caller_frame = state.callstack.pop()
        state.callstack.push(strcpy_frame)
        ret_addr = caller_frame.ret_addr
        addr = strcpy_frame.current_stack_pointer
        while True:
            data = state.memory.load( addr, 8, endness=archinfo.Endness.LE )
            if state.solver.is_true(data == ret_addr):
                return addr
            addr += increment


    def getMemContents(state, start, end):
        strcpy_frame = state.callstack.top
        mem_contents = []
        for addr in range( start, end ):
            data = state.memory.load( addr, 1, endness=archinfo.Endness.LE )
            mem_contents.append(data)
        return mem_contents
        

    def getRuntimeStackInfo(state):
        # change to increments of 1 to support non 8-bit aligned memory at the cost of performance
        increment = 8
        buff_addr = state.regs.rdi
        ret_addr  = getRetAddressAddr(state, increment) 
        buff_addr_raw = state.solver.eval(buff_addr)
        data_inbetween = getMemContents(state, buff_addr_raw+8, ret_addr) # skip the buff_addr
        return buff_addr, ret_addr, data_inbetween


    buff_addr, addr_ret_addr, data_inbetween = getRuntimeStackInfo(v_state)


    '''
    For debugging
    '''

    # dump buffer address and content
    print("buffer address: ")
    # 5 is hardcoded
    buff_data = v_state.memory.load(buff_addr, 5, endness=archinfo.Endness.LE)
    print(hex(v_state.solver.eval(buff_addr)), buff_data, sep=" : ")

    # dump return address and its address
    print("address of return address: ")
    ret_addr = v_state.memory.load(addr_ret_addr, 8, endness=archinfo.Endness.LE)
    print(hex(addr_ret_addr), ret_addr, sep=" : ")

    # dump data stored in between buffer and ret addr
    print("stack data in between:")
    print([hex(v_state.solver.eval(no)) for no in data_inbetween])

    # memory dump to help debug
    # print(v_state.memory.load( v_state.callstack.current_stack_pointer, 64, endness=archinfo.Endness.LE))  
    
    
if __name__ == '__main__':
    # main()
    print(repr(main()))


# Usefull adresses:
# function: 0x40068a
# main: 0x4006e8
    
# Dump of assembler code for function main:
#    0x00000000000006b0 <+0>:     push   %rbp
#    0x00000000000006b1 <+1>:     mov    %rsp,%rbp
#    0x00000000000006b4 <+4>:     sub    $0x20,%rsp
#    0x00000000000006b8 <+8>:     mov    %edi,-0x14(%rbp)
#    0x00000000000006bb <+11>:    mov    %rsi,-0x20(%rbp)
#    0x00000000000006bf <+15>:    movl   $0x0,-0x4(%rbp)
#    0x00000000000006c6 <+22>:    mov    -0x20(%rbp),%rax
#    0x00000000000006ca <+26>:    add    $0x8,%rax
#    0x00000000000006ce <+30>:    mov    (%rax),%rax
#    0x00000000000006d1 <+33>:    mov    %rax,%rdi
#    0x00000000000006d4 <+36>:    callq  0x68a <function>
#    0x00000000000006d9 <+41>:    movl   $0x1,-0x4(%rbp)
#    0x00000000000006e0 <+48>:    mov    -0x4(%rbp),%eax
#    0x00000000000006e3 <+51>:    mov    %eax,%esi
#    0x00000000000006e5 <+53>:    lea    0x98(%rip),%rdi        # 0x784
#    0x00000000000006ec <+60>:    mov    $0x0,%eax
#    0x00000000000006f1 <+65>:    callq  0x560 <printf@plt>
#    0x00000000000006f6 <+70>:    nop
#    0x00000000000006f7 <+71>:    leaveq 
#    0x00000000000006f8 <+72>:    retq   
# End of assembler dump.

# Dump of assembler code for function function:
#    0x000000000000068a <+0>:     push   %rbp
#    0x000000000000068b <+1>:     mov    %rsp,%rbp
#    0x000000000000068e <+4>:     sub    $0x20,%rsp
#    0x0000000000000692 <+8>:     mov    %rdi,-0x18(%rbp)
#    0x0000000000000696 <+12>:    movb   $0x0,-0x1(%rbp)
#    0x000000000000069a <+16>:    mov    -0x18(%rbp),%rdx
#    0x000000000000069e <+20>:    lea    -0x5(%rbp),%rax
#    0x00000000000006a2 <+24>:    mov    %rdx,%rsi
#    0x00000000000006a5 <+27>:    mov    %rax,%rdi
#    0x00000000000006a8 <+30>:    callq  0x550 <strcpy@plt>
#    0x00000000000006ad <+35>:    nop
#    0x00000000000006ae <+36>:    leaveq 
#    0x00000000000006af <+37>:    retq   
# End of assembler dump.